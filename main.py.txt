import json
import os
import base64
import logging
import datetime
from flask import Flask, request, jsonify,Response
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from google.cloud.sql.connector import Connector
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)
app = Flask(__name__)
connector = Connector()
 
DB_CONFIG = {
    "INSTANCE_CONNECTION_NAME": os.getenv("INSTANCE_CONNECTION_NAME", "prj-abffsl-datalayer-nonprod02:asia-south1:postgresql-db-gcp-abfssl-datalayer-nonprod02"),
    "database": os.getenv("DB_NAME", "datalayerdb"),
    "user": os.getenv("DB_USER", "dataplatform2apiuat"),
    "password": os.getenv("DB_PASSWORD", "QZa~5vpXU2u7N|Zj"),
    "schema_name": os.getenv("SCHEMA_NAME", "stg"),
    "sms_table": os.getenv("SMS_TABLE", "sms_spend_view")
}
 
connector = Connector()
 
# AES Encryption Config
AES_KEY = b"a1d2c3d4f5l9972029m1a4c86d9e8l90"  # 32-byte key for AES-256
AES_IV = b"1675aldd5106eddh"  # 16-byte IV
 
# Encryption function
def encrypt(plain_text):
    cipher = Cipher(algorithms.AES(AES_KEY), modes.CBC(AES_IV), backend=default_backend())
    encryptor = cipher.encryptor()
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plain_text.encode('utf-8')) + padder.finalize()
    encrypted = encryptor.update(padded_data) + encryptor.finalize()
    return base64.urlsafe_b64encode(encrypted).decode('utf-8')
 
# Decryption function
def decrypt(cipher_text):
    try:
        if len(cipher_text) % 4 != 0:
            cipher_text += "=" * (4 - len(cipher_text) % 4)  # Fix padding if necessary
        cipher = Cipher(algorithms.AES(AES_KEY), modes.CBC(AES_IV), backend=default_backend())
        decryptor = cipher.decryptor()
        encrypted_data = base64.urlsafe_b64decode(cipher_text)
        decrypted_padded = decryptor.update(encrypted_data) + decryptor.finalize()
        unpadder = padding.PKCS7(128).unpadder()
        decrypted = unpadder.update(decrypted_padded) + unpadder.finalize()
        return decrypted.decode('utf-8')
    except Exception as e:
        return f"Error during decryption: {str(e)}"
 
def get_db_connection():
    try:
        print("Connecting to database...")
        conn = connector.connect(
            DB_CONFIG["INSTANCE_CONNECTION_NAME"],
            "pg8000",
            user=DB_CONFIG["user"],
            password=DB_CONFIG["password"],
            db=DB_CONFIG["database"],
            ip_type="PRIVATE"
        )
        print("Database connection established.")
        return conn
    except Exception:
        print(f"Error connecting to DB.",exc_info=True)
        return None
 
@app.route("/fetch-sms-spend-view", methods=["POST"])
def fetch_dues():
    req_json = request.get_json(silent=True)
    print("request json:",req_json)
    if not req_json or 'data' not in req_json:
        return jsonify({"data": encrypt(json.dumps({"error": "Missing data parameter"}))}), 400
 
    try:
        decrypted_text = decrypt(req_json['data'])
        print("Decrypted text:",decrypted_text)
        if not decrypted_text.strip().startswith('{'):
            if ":" in decrypted_text:
                key, value = decrypted_text.split(":", 1)
                decrypted_text = json.dumps({key.strip(): value.strip()})
        decrypted_request = json.loads(decrypted_text)
        print(decrypted_request)
        
        user_id = decrypted_request.get("mobile_number")
        print("id:", user_id)
        if not user_id:
            return jsonify({"data": encrypt(json.dumps({"error": "Missing user id"}))}), 400
    except Exception as e:
        return jsonify({"data": encrypt(json.dumps({"error": "Invalid or undecryptable data", "details": str(e)}))}), 400
 
    query = f"""
        SELECT * FROM {DB_CONFIG['schema_name']}.{DB_CONFIG['sms_table']}
       WHERE sms_spend_view->>'user_id' = %s; 
    """
    print("query:",query)

    results = []
 
    try:
        conn = get_db_connection()
        if not conn:
            print("connection:failed.")
            return jsonify({"data": encrypt(json.dumps({"error": "Failed to connect to the database"}))}), 500
        print("connection successful.")    
 
        cursor = conn.cursor()
        print (f"Debug: Executing query with user_id: {user_id}")
        cursor.execute(query, (int(user_id),))
        rows = cursor.fetchall()
        print (f"Debug: number of rows fetched: {len(rows)}")
        results=[row[0] for row in rows]

        #columns = [desc[0] for desc in cursor.description]
        #print (f"Debug: Columns: {columns}")

        #for row in rows:
         #   row_data = dict(zip(columns, map(str, row)))
          #  results.append(row_data)
           # print (f"Debug: row data: {row_data}")
            #category = row_data.pop("category")
            #results.setdefault(category, []).append(row_data)
 
        #for row in rows:
        #    row_data = dict(zip(columns, map(str, row)))
        #    category = row_data.pop("category")
        #    results[category].append(row_data)
 
        cursor.close()
        conn.close()
        if not results:
            return jsonify({"data": encrypt(json.dumps({"error": "No data found for given mobile_number"}))}), 404
 
        return Response(json.dumps({"data": encrypt(json.dumps(results))}), mimetype="application/json")
 
    except Exception as e:
        log.error("Exception occurred during query execution", exc_info=True)
        return jsonify({"data": encrypt(json.dumps({"error": "Query not executed", "details": str(e)}))}), 500
 

        #if not any(results.values()):
            #print ("Debug: number of rows fetched: {len(rows)}")
            #return jsonify({"data": encrypt(json.dumps({"error": "No data found for given customer id"}))}), 404

        #print("debug: successfully fetched")
       # return Response(json.dumps({"data": encrypt(json.dumps(results))}), mimetype="application/json")
 
   # except Exception:
       # log.error(f"Exception occurred.",exc_info=True)
       # return jsonify({"data": encrypt(json.dumps({"error": "Query not executed"}))}), 500
 
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))
 
 
